编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。

为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。

汇编语言是经过编译后与 CPU 直接沟通的。

学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。
**寄存器不依靠地址区分数据，而依靠名称。**每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。

我们常常看到 32 位 CPU、64 位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是 4 个字节。

#内存模型：Heap（堆）寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从 0x1000 到 0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。这种因为*用户主动请求而划分出来的内存区域，叫做 Heap（堆）*。它由起始地址开始，从低位（地址）向高位（地址）增长。

#### 重要特点：Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

# 内存模型：Stack（栈）除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，**Stack 是由于函数运行而临时占用的内存区域。**

请看下面的例子。

```
int main() {
   int a = 2;
   int b = 3;
}
```

上面代码中，系统开始执行 main 函数时，会为它在内存里面建立一个帧（frame），所有 main 的内部变量（比如 a 和 b）都保存在这个帧里面。main 函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

![](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png)
一般来说，调用栈有多少层，就有多少帧。

所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。

Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是 0x8000，第一帧假定是 16 字节，那么下一次分配的地址就会从 0x7FF0 开始；第二帧假定需要 64 字节，那么地址就会移动到 0x7FB0。

7.1 一个实例了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序 example.c。

```javascript
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```

gcc 将这个程序转成汇编语言。

```javascript
$ gcc -S example.c
```
